#include <string>
#include <vector>
#include <unordered_set>
#include <unordered_map>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <memory>
#include <iostream>
#include <cmath>
#include <stack>
#include <queue>
#include <regex>

namespace aoc {
/**
 * Generic hashing function generated by chatgpt
 */
template <typename T>
inline void hash_combine(size_t& seed, T const& v) {
    size_t h = std::hash<T>{}(v);
    seed ^= h + 0x9e3779b97f4a7c15ULL + (seed << 6) + (seed >> 2);
}

struct pair_hash {
    template<class A, class B>
    size_t operator()(std::pair<A, B> const&p) const noexcept {
        size_t seed = 0;
        hash_combine(seed, p.first);
        hash_combine(seed, p.second);
        return seed;
    }
};

/**
 * Read all data from standard input into a string.
 *
 * Useful for reading puzzle input pasted into stdin instead of reading from
 * a file. Returns an empty string if no data is available on stdin.
 */
inline std::string read_stdin_all() {
    std::ostringstream ss;
    ss << std::cin.rdbuf();
    return ss.str();
}

/**
 * Split a string by a delimiter substring.
 *
 * @param s Input string to split.
 * @param delim Delimiter string. If empty, returns the original string as
 *              the only element.
 * @return Vector of tokens in order. Tokens are returned as-is (no trimming).
 */
inline std::vector<std::string> split(const std::string &s, const std::string &delim) {
    std::vector<std::string> out;
    if (delim.empty()) { out.push_back(s); return out; }
    std::size_t pos = 0;
    std::size_t dlen = delim.size();
    while (true) {
        auto nxt = s.find(delim, pos);
        if (nxt == std::string::npos) {
            out.push_back(s.substr(pos));
            break;
        }
        out.push_back(s.substr(pos, nxt - pos));
        pos = nxt + dlen;
    }
    return out;
}
inline std::vector<std::string> split(const std::string& s, const std::regex& re) {
    std::sregex_token_iterator it(s.begin(), s.end(), re, -1);  // -1 means split by the delimiter
    std::sregex_token_iterator end;

    std::vector<std::string> result;
    for (; it != end; it++) {
        result.push_back(it->str());  // Push the substring to the result vector
    }

    return result;
}

/**
 * Convert a list of numeric strings to a vector of a numeric type.
 *
 * Empty strings in the input are skipped.
 *
 * Note: this implementation uses std::stoll and casts to T. For unsigned
 * types you can still use this (values must fit into long long) or replace
 * the body with from_chars/stoull/stoll based on your needs.
 */
template <typename T>
inline std::vector<T> lines_to_numbers(const std::vector<std::string>& lines) {
    static_assert(std::is_arithmetic<T>::value, "T must be an arithmetic type (integral or floating point)");

    std::vector<T> out;
    out.reserve(lines.size());

    for (const auto& l : lines) {
        if (l.empty()) continue;

        try {
            if constexpr (std::is_floating_point<T>::value) {
                // Use std::stod for floating-point types (e.g., double, float)
                out.push_back(static_cast<T>(std::stod(l)));
            } else if constexpr (std::is_unsigned<T>::value) {
                // Use std::stoull for unsigned types (e.g., size_t, unsigned long long)
                out.push_back(static_cast<T>(std::stoull(l)));
            } else {
                // Use std::stoll for signed types (e.g., long long, int)
                out.push_back(static_cast<T>(std::stoll(l)));
            }
        } catch (const std::invalid_argument& e) {
            // Handle invalid input (non-numeric string)
            std::cerr << "Invalid argument: " << e.what() << " for string: " << l << std::endl;
        } catch (const std::out_of_range& e) {
            // Handle overflow (value too large)
            std::cerr << "Out of range: " << e.what() << " for string: " << l << std::endl;
        }
    }

    return out;
}

/**
 * Trim leading and trailing ASCII whitespace from a string in-place.
 *
 * @param s String to trim. Modified in-place.
 */
inline void trim(std::string &s) {
    s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](unsigned char ch){ return !std::isspace(ch); }));
    s.erase(std::find_if(s.rbegin(), s.rend(), [](unsigned char ch){ return !std::isspace(ch); }).base(), s.end());
}

} // namespace aoc
