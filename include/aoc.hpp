#include <string>
#include <vector>
#include <unordered_set>
#include <unordered_map>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <memory>
#include <iostream>
#include <cmath>
#include <stack>
#include <queue>
#include <regex>

namespace aoc {
/**
 * Generic hashing function generated by chatgpt
 */
template <typename T>
inline void hash_combine(size_t& seed, T const& v) {
    size_t h = std::hash<T>{}(v);
    seed ^= h + 0x9e3779b97f4a7c15ULL + (seed << 6) + (seed >> 2);
}

struct pair_hash {
    template<class A, class B>
    size_t operator()(std::pair<A, B> const&p) const noexcept {
        size_t seed = 0;
        hash_combine(seed, p.first);
        hash_combine(seed, p.second);
        return seed;
    }
};

/**
 * Read a text file into a vector of lines.
 *
 * @param path Path to the input file.
 * @return Vector where each element is a single line from the file.
 *         Returns an empty vector when the file cannot be opened or is empty.
 */
inline std::vector<std::string> read_lines(const std::string& path) {
    std::ifstream in(path);
    std::vector<std::string> lines;
    std::string line;
    while (std::getline(in, line)) lines.push_back(line);
    return lines;
}

/**
 * Read an entire file into a single string.
 *
 * @param path Path to the input file.
 * @return File contents as a string. If the file can't be opened the
 *         returned string will be empty.
 */
inline std::string read_all(const std::string& path) {
    std::ifstream in(path);
    std::ostringstream ss;
    ss << in.rdbuf();
    return ss.str();
}

/**
 * Read all data from standard input into a string.
 *
 * Useful for reading puzzle input pasted into stdin instead of reading from
 * a file. Returns an empty string if no data is available on stdin.
 */
inline std::string read_stdin_all() {
    std::ostringstream ss;
    ss << std::cin.rdbuf();
    return ss.str();
}

/**
 * Split a string by a delimiter substring.
 *
 * @param s Input string to split.
 * @param delim Delimiter string. If empty, returns the original string as
 *              the only element.
 * @return Vector of tokens in order. Tokens are returned as-is (no trimming).
 */
inline std::vector<std::string> split(const std::string &s, const std::string &delim) {
    std::vector<std::string> out;
    if (delim.empty()) { out.push_back(s); return out; }
    std::size_t pos = 0;
    std::size_t dlen = delim.size();
    while (true) {
        auto nxt = s.find(delim, pos);
        if (nxt == std::string::npos) {
            out.push_back(s.substr(pos));
            break;
        }
        out.push_back(s.substr(pos, nxt - pos));
        pos = nxt + dlen;
    }
    return out;
}

inline int parse_to_int(std::string s) {
    try {
        int num = std::stoi(s);
        return num;
    } catch (const std::invalid_argument& e) {
        std::cerr << "Invalid argument: " << s << std::endl;
        return -1;
    }
}

/**
 * Convert a list of numeric strings to a vector of ints.
 *
 * Empty strings in the input are skipped.
 *
 * @param lines Vector of strings, each expected to contain a decimal integer.
 * @return Vector of parsed integers in the same order as non-empty input lines.
 */
inline std::vector<int> lines_to_ints(const std::vector<std::string>& lines) {
    std::vector<int> out;
    out.reserve(lines.size());
    for (auto &l : lines) if (!l.empty()) out.push_back(std::stoi(l));
    return out;
}

/**
 * Trim leading and trailing ASCII whitespace from a string in-place.
 *
 * @param s String to trim. Modified in-place.
 */
inline void trim(std::string &s) {
    s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](unsigned char ch){ return !std::isspace(ch); }));
    s.erase(std::find_if(s.rbegin(), s.rend(), [](unsigned char ch){ return !std::isspace(ch); }).base(), s.end());
}

} // namespace aoc
